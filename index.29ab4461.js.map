{"mappings":"CAmVsCA,iBACpC,MAEMC,EADM,CAAC,UAAW,SAAU,WACZC,KAAIF,MAAMG,IAC9B,MAAMC,QAAiBC,MAAM,uCAASF,KACtC,IAAKC,EAASE,GACZ,MAAM,IAAIC,MAAM,aAElB,OAAOH,EAASI,MAAM,IAKxB,aADmBC,QAAQC,WAAWT,E,EAIxCU,GACGC,MAAKC,IACYA,EACbC,QAAO,EAACC,OAAEA,KAAwB,cAAXA,IACvBb,KAAI,EAACc,MAAEA,KAAYA,IACPH,EAAKC,QAAO,EAACC,OAAEA,KAAwB,aAAXA,GAAsB,IAElEE,OAAMC,GAASC,QAAQC,IAAIF","sources":["src/index.js"],"sourcesContent":["/* для понимания:\n\nhttp/1.1\nзапрос на страницу\nзапрос на стили\nзапрос на стили\n\n*/\n\n/* http/2\n\nзапрос на страницу\nпаралельный запрос на стили и скрипты\n\npostman - запрос на бекенд без написания кода\nSOAP API (более защищенная, тяжело парсится, базируется на формате XML, тяжело сформировать хттп-запрос)\nREST API (максимально быстрая, передаёт данные в формате JSON, но не слишком большие и менее защищённая)\n\n*/\n\n/* \n\nТИПЫ ЗАПРОСОВ\n\nGET - ПОЛУЧЕНИЕ\nPOST - СОЗДАНИЕ\nPUT/PATCH - ОБНОВЛЕНИЕ\nDELETE - УДАЛЕНИЕ\n\n*/\n\n/* \n\nвыбираем эндпоинт https://swapi.dev/api/films/ - (films - это эндпоинт (функция))\nсмотрим на request параметры (прийдут, как параметры функции) - формируется через ?\nесли больше 1 параметра, разделяем знаком &\n*/\n\n/* \n\nКросс-доменные запросы - защита от посторонних запросов\n\nесть домен ресурса: rozetka.com\nвкладка network (отвечает за http-запросы)\nвкладка Headers - referer: домен, с которого уходит запрос на бекенд\nна бекенде есть массив с названиями сайтов, кому можна доверять\nесли сайта нет, будет CORS-ошибка (Request Header -> origin -> error)\n\nPOSTMAN - отдаст, но не факт, что будет работать через fetch.\n*/\n\n//==============\n\n// Пагинация\n\n// const BASE_URL = 'https://the-one-api.dev/v2';\n// const END_POINT = 'character';\n// const KEY = 'pTksQP-kRtSZO_M71kE_';\n\n// function getCharacter() {\n//   const param = new URLSearchParams({\n//     limit: 30,\n//     page: 1,\n//   });\n\n//   //   опция для типа запроса\n//   const option = {\n//     method: 'GET',\n//     headers: {\n//       Authorization: `Bearer ${KEY}`,\n//     },\n//   };\n\n//   fetch(`${BASE_URL}${END_POINT}?${param}`, option).then(response =>\n//     console.log(response)\n//   );\n// }\n\n// getCharacter();\n\n//==============\n\n// const BASE_URL = 'https://api.themoviedb.org/3';\n// const END_POINT = 'trending/movie/day';\n// const API_KEY = '155ac852b40c3d4bc41678b5b0356daa';\n// const list = document.querySelector('.js-list');\n\n// function getTrending() {\n//   fetch(`${BASE_URL}${END_POINT}?api_key=${API_KEY}&page=20`).then(response => {\n//     if (!response.ok) {\n//       throw new Error(response.statusText);\n//     }\n\n//     return response.json();\n//   });\n// }\n\n// getTrending()\n//   .then(data =>\n//     list.insertAdjacentHTML('beforeend', createMarkup(data.results))\n//   )\n//   .catch(err => console.log(err));\n\n// function createMarkup(arr) {\n//   return arr\n//     .map(\n//       ({ poster_path, title }) => `<li>\n//     <img  src=\"https://image.tmdb.org/t/p/w300${poster_path}\" alt=\"${title}\">\n//     <h2>${title}</h2>\n//   </li>`\n//     )\n//     .join('');\n// }\n\n//==============\n\n// CRUD - Create Read Update Delete\n// топ-5 запросов на бекенд\n// json placeholder - api\n\n// R - GET\n// работаем в Postman с вкладкой Body (form-data или raw - струкутура в формате json)\n\n// fetch('https://jsonplaceholder.typicode.com/posts/1')\n//   .then(response => response.json())\n//   .then(json => console.log(json));\n\n// {\n//   id: 1,\n//   title: '...',\n//   body: '...',\n//   userId: 1\n// }\n\n// C - POST\n\n// опции (строгая структура)\n// body - формат json\n// POST (отличие от GET) должен передать какую-то информацию\n// должен быть статус 201, в отличии от GET (200)\n\n// const addPost = document.querySelector('.js-add');\n// const listPosts = document.querySelector('.js-posts');\n// const formWrapper = document.querySelector('.js-form');\n// const errMessage = document.querySelector('.js-error');\n\n// addPost.addEventListener('click', handlerAddPost);\n\n// function handlerAddPost() {\n//   formWrapper.innerHTML = `\n//   <form action=\"submit\" class=\"js-form-add\" style: \"style=\"display: flex; flex-direction: column\">\n//   <input type=\"text\" name=\"name\" />\n//   <textarea name=\"description\" type=\"text\" cols=\"30\" rows=\"10\"></textarea>\n//   <button>Add Post</button>\n//   </form>`;\n\n//   const form = document.querySelector('.js-form-add');\n//   form.addEventListener('submit', handlerFormSubmit);\n// }\n\n// function handlerFormSubmit(event) {\n//   event.preventDefault();\n\n//   const { name, description } = event.currentTarget.elements;\n\n//   // с функции никогда не отдавать готовый json\n//   // строгий образец:\n//   const data = {\n//     title: name.value,\n//     body: description.value,\n//   };\n\n//   addPostService(data)\n//     .then(() => {\n//       listPosts.insertAdjacentHTML('beforeend', createPostMarkup(data));\n//     })\n//     .catch(() => {\n//       errMessage.innerHTML = 'Can`t add a post';\n//     })\n//     .finally(() => {\n//       formWrapper.innerHTML = '';\n//       setTimeout(() => {\n//         errMessage.innerHTML = '';\n//       }, 2000);\n//     });\n// }\n\n// function createPostMarkup({ id, title, body }) {\n//   return `<li data-id=\"id\">\n//   <h2>${title}</h2>\n//   <p>${body}</p>\n// </li>`;\n// }\n\n// function addPostService(data) {\n//   // строгий образец:\n//   const options = {\n//     method: 'POST',\n//     headres: {\n//       'Content-type': 'application/json',\n//     },\n//     body: JSON.stringify(data),\n//   };\n\n//   return fetch('https://jsonplaceholder.typicode.com/posts', options).then(\n//     response => {\n//       if (!response.ok) {\n//         throw new Error(response.statusText);\n//       }\n//       return response.json();\n//     }\n//   );\n// }\n\n//==============\n\n// U - PUT/PATCH\n// так же, как и при POST, но с указанием id (обязательно)\n// PUT (используется редко, нет нужды обновлять объект полностью) - обновляет всю структуру, кроме id\n// при недостаточном кол-ве элементов, все остальные будут удалены\n\n// const options = {\n//   method: 'PUT',\n//   body: JSON.stringify({\n//     id: 1,\n//     title: 'cat',\n//   }),\n//   headers: { 'Content-type': 'application/json' },\n// };\n\n// fetch('https://jsonplaceholder.typicode.com/posts/1', options)\n//   .then(response => response.json())\n//   .then(data => console.log(data));\n\n// PATCH - обновляет 1 элемент, который нужно обновить (используется чаще)\n// const options = {\n//   method: 'PUT',\n//   body: JSON.stringify({\n//     id: 1,\n//     title: 'cat',\n//     body: 'Hello dear cat',\n//     email: 'test@gmail.com',\n//   }),\n//   headers: { 'Content-type': 'application/json' },\n// };\n\n// fetch('https://jsonplaceholder.typicode.com/posts/1', options)\n//   .then(response => response.json())\n//   .then(data => console.log(data))\n//   .catch(err => console.log(err));\n\n// D - DELETE\n// Указывается только тот элемент, который надо удалить\n\n// const options = {\n//   method: 'DELETE',\n// };\n\n// fetch('https://jsonplaceholder.typicode.com/posts/1', options).then(response =>\n//   console.log(response)\n// );\n\n//==============\n\n// асинх функции\n// 'https://restcountries.com/v3.1/name/'\n\n// async function getCapital() {\n//   // try/catch - в случае, когда с данными работаем внутри функции\n//   try {\n//     const URL = 'https://restcountries.com/v3.1/name/';\n//     const response = await fetch(`${URL}Ukraine`);\n//     if (!response.ok) {\n//       throw new Error(response.statusText);\n//     }\n//     const data = await response.json();\n//     console.log(data);\n//   } catch (error) {\n//     console.log(error);\n//   }\n//   console.log('end');\n// }\n\n// getCapital();\n\n//==============\n\n// когда надо обрабатывать данные, которые будут возвращаться вне функции\n// return\n// then/catch\n\n// async function getCapital() {\n//   const URL = 'https://restcountries.com/v3.1/name/';\n//   const response = await fetch(`${URL}Ukraine`);\n//   if (!response.ok) {\n//     throw new Error(response.statusText);\n//   }\n//   return response.json();\n// }\n\n// getCapital()\n//   .then(data => console.log(data))\n//   .catch(error => console.log(error));\n\n//==============\n\n// любая функция может стать асинх\n// всегда возвращает промис\n\n// делятся на 2 случая обработки:\n// если запрос обрабатывается внутри (без return) - обрабатываем с помоцью try (запрос, проверка на статус, парс респонса и тд) / catch (пишется возможная ошибка)\n// если за пределы - обработка при помощи then / catch\n\n// async function foo() {}\n\n// console.log(foo());\n\n// // arrow async\n// const arrow = async () => {};\n// // exp asynce\n// const exp = async function () {};\n\n// const user = {\n//   async getFoo() {},\n//   getInfo: async function () {},\n//   getTest: async () => {},\n// };\n\n//==============\n\n// парал и послед запросы\n// promise.all() - обрабатывает все УСПЕШНЫЕ респонсы\n// Promise.allSettled - обрабатывает ВСЕ респонсы и добавит флажок\n// Promise.race()​\n// Promise.resolve()\n// Promise.reject()\n\n// Параллельные запросы\n// обрабатываем во внешний код, по этому try/catch не нужен\nasync function getCapital() {\n  const URL = 'https://restcountries.com/v3.1/name/';\n  const arr = ['Ukraine', 'France', 'Germany'];\n  const responses = arr.map(async country => {\n    const response = await fetch(`${URL}${country}`);\n    if (!response.ok) {\n      throw new Error('Not Found');\n    }\n    return response.json();\n  });\n\n  // метод allSettled\n  const prom = await Promise.allSettled(responses);\n  return prom;\n}\n\ngetCapital()\n  .then(data => {\n    const resolve = data\n      .filter(({ status }) => status === 'fulfilled')\n      .map(({ value }) => value);\n    const reject = data.filter(({ status }) => status === 'rejected');\n  })\n  .catch(error => console.log(error));\n// асинх функция всегда возвращает промис\n"],"names":["async","responses","map","country","response","fetch","ok","Error","json","Promise","allSettled","$1f0dc3b9307be026$var$getCapital","then","data","filter","status","value","catch","error","console","log"],"version":3,"file":"index.29ab4461.js.map"}